"use server"

import { sql } from '@vercel/postgres';
// import jwt
import jwt from "jsonwebtoken"
import bcrypt from "bcrypt"

// creating a db is invalid since vercel/postgres has already created a db for us.
/*try {
    createDb()
} catch (error) {

    console.log(`error recieved while creating database:\n ${error}`)
}
//valid for sql functions only
async function createDb(){
    await sql`CREATE DATABASE IChange;`
}*/



// for sql as well
async function createTable(){
    await sql`CREATE TABLE users (
        Email varchar(255),
        UserName varchar(255),
        Telephone int,
        Skill varchar(255),
        Region varchar(255),
        Password varchar(255),
        Salt varchar(255)
    );`
}

export async function login(userReceived){
    return new Promise(async function(resolve,reject){
        let user = userReceived
        console.log(`login function reached`)

        let {err,userFound} = await collectionSearcher(user)
        console.log(`err found: ${err} and document found: ${userFound}`)
        if(err != null){
            //for error
            console.log(`error found in login${err}`)
            resolve({err:err,documentFound:userFound})
        }
        else{
            // I have returned the function in this way so that it may return whatever result is obtained from here as the final result.
            return loginHashpassword(user,userFound).then(function(hash){
                if(hash ==  userFound.password){
                    console.log("password match detected")
                    // throw no error so that the method accepts the login
                    err = null
                    // This is where the jwt is generated by being signed.
                    let token = jwt.sign(user,process.env.JWT_SECRET_KEY)
                    let userName = user.userName
                    let tokenAndUser = `${token},${userName}`
                    resolve({err: err,documentFound: tokenAndUser})
                }
                else{
                    err = "invalid password"
                    console.log(`error at the login function, ${err}`)
                    resolve({err: err,documentFound: null})                
                }
            }).catch(function(error){
                console.log(error)
                err = "internal server error"
                console.log(err)
                resolve({err: err,documentFound: null})   
            })
        }
    
    })
}



async function loginHashpassword(userReceived,userRetrieved){
    let user = userReceived
    let salt = userRetrieved.salt
    console.log(`salt found here is: ${salt}`)
    return new Promise(async function(resolve,reject){
        await bcrypt.hash(user.password,salt,function(error,hash){
            if(error){
                reject("corrupted credentials")
            }
            else{
                resolve(hash)
            }
        })
    })
}

async function collectionSearcher(userReceived){
    let user = userReceived

    let documentFound =  await sql`SELECT * FROM Users WHERE Email == userReceived.email;`;
    console.log(`document found at collection searcher: ${JSON.stringify(documentFound)}`)
    // this documentFound.command propert am only using for the vercel/postgress,
    // for mongodb the documentFound is just enough.
    if(documentFound.command != null && documentFound.command != undefined){
        //make them objects since arrays can't containt different types
        return {err:null,userFound:documentFound.rows}
    }
    else{
        let err = "no user found"
        console.log(`at the collection searcher: ${err}`)
        // meaning theres no user found and so its safe to store the user.
        return {err:err,userFound:null}
    }
}


// the signup function
export async function signUp(userReceived){
    // try to create the table if it doesn't exist, if it does then it will throw an error.
    try {
        createTable
    } catch (error) {
        console.log(`error recieved while creating table:\n ${error}`)
    }

    return new Promise(async function(resolve,reject){
        let user = userReceived


        // The problem here was deep nesting of asynchronous functions and its what brought up the errors
        // Thats why am campaignig for no more than one nesting, 
        // the hash password function here was the nested function
        let {err,documentFound} = await duplicateTest(user)
        if(err == "successful signup"){
            resolve({err: null,documentFound: documentFound})        
        }
        else if(err){
            resolve({err:err,result:documentFound}) 
        }
        else{
            resolve({err: null,documentFound: "user signed up"}) 
        }
    })
}

async function duplicateTest(userReceived){
    let user =  userReceived
    
    let {err,userFound} = await collectionSearcher(user)
    // since for a signup this is not an error dont throw an error
    if(err == "no user found"){
        let salt = await bcrypt.genSalt(12)
        user.salt = salt
        console.log(user.salt)
        bcrypt.hash(user.password,salt,async function(error,hash){
            if(error){
                fn("corrupted credentials",null)
            }
            else{
                user.password = hash
                // ensure you stick to the order. and not call an error when its actually not an error.
                // await userModel.insertOne({userName: user.userName,fullName:user.fullName,email: user.email,password: user.password})
                // Note that for mongoose model has only an insertMany and no insertOne
                try {
                    let insertResult = await sql`INSERT INTO Users (Email,UserName, Telephone,Skill,Region,Password,Salt)
                    VALUES (user.email,user.userName,user.phone,user.skill,user.region,user.password,salt: salt);`
                    if(insertResult.command == "INSERT"){
                        return{err: "successful signup",documentFound:userFound}
                    }                         
                } catch (error) {
                    console.log(`error inserting data: ${error}`)
                    return{err: "oops sorry please try again",documenFound:userFound}
                }
                // create an object for acknowledging a successful insertion in order to confirm a sucessful signup
            }
        })
        return {err: "successful signup",documentFound:userFound}
    }
    else if(userFound != null){
        return {err:"name duplicated",documentFound:null}
    }
    else{
        return {err:err,documentFound: userFound}    
    }
}
